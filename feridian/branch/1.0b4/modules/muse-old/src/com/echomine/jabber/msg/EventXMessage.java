package com.echomine.jabber.msg;

import com.echomine.common.ParseException;
import com.echomine.jabber.JabberCode;
import com.echomine.jabber.JabberJDOMMessage;
import com.echomine.jabber.JabberMessage;
import com.echomine.jabber.JabberMessageParser;
import org.jdom.Element;

import java.util.List;

/**
 * <p>This class supports the jabber:x:event namespace.  It gives the ability to work
 * with incoming events and also creating outgoing events.  You add the X Message to an existing Message.
 * The composing event is generated when the user is actively typing a reply to the message. If the user never completes/sends
 * the reply (or after an idle timeout), an empty jabber:x:event (just contains the id element) should be sent to "clear" the
 * outstanding composing event. It is suggested that the client first check to make sure the recipient of a composing event is
 * also in the roster, as it may not be desireable to send such availability information to unknown contacts.
 * The way the event works is this:  First, someone submits a message telling you what kinds of events it can
 * support (or willing to listen to) and includes a message ID.  Then recipient then can start sending back
 * events specific for that message, but must include the <id> element inside the message that corresponds
 * to the original message id.</p> <p>Receiving Event Requests: You can retrieve sender's willingness to receive certain
 * events by simply calling to see which event it advertised itself to see. Multiple events can be set so each event
 * that you're interested in should be checked.</p> <p>Sending Event Requests: You can send a request along with the message
 * to indicate what events you like the remote to send.  You can set multiple event types you want to listen for.  Note that,
 * if you set the message ID for the event class, the message is then considered a event reply (not a request anymore).
 * In this case, the <offline> event will automatically be cleared because that event is generated by the server, not you.</p>
 * <p>Receiving Event Replies: you can retrieve information about event replies to your event requests just
 * as you normally would.  The only way to tell if the event is a reply and not a request is by looking
 * to see if there is a event Message ID associated with it.</p>
 * <p>Sending Event Replies: Sending event replies is the same as sending requests, except for the fact that
 * you need to include the original requestor's message ID inside the event to distinguish it as a reply and
 * not a request.  You should technically send one event type per event message indicating your current
 * status (delivered, composing, displayed).</p> <p>Caveats: If you happen to send a composing event reply and would like to
 * clear out the status due to some inactivity or idle time such that the composing message was never sent, then after an idle
 * time period, you should submit another event message that contains only the message id (but no events).</p>
 * <p><b>Current Implementation: <a href="http://www.jabber.org/jeps/jep-0022.html">JEP-0022 Version 1.1</a></b></p>
 */
public class EventXMessage extends JabberJDOMMessage implements JabberCode {
    public static final String EVENT_OFFLINE = "offline";
    public static final String EVENT_DELIVERED = "delivered";
    public static final String EVENT_COMPOSING = "composing";
    public static final String EVENT_DISPLAYED = "displayed";
    private boolean offline;
    private boolean delivered;
    private boolean composing;
    private boolean displayed;
    private String msgID;

    /**
     * constructs a default Delay message (with the x element)
     */
    public EventXMessage() {
        super(new Element("x", XMLNS_X_EVENT));
    }

    /**
     * this will reset all the flags to false. Basically it means the message
     * won't send any events.  The message ID will also be reset.
     */
    public void reset() {
        offline = delivered = composing = displayed = false;
        msgID = null;
    }

    /**
     * retrieves the sender's message ID associated with the event.  This is NOT
     * the message ID of the message itself since X Messages never use those message ID's.
     *
     * @return the event message ID or null if none exists
     */
    public String getEventMessageID() {
        return msgID;
    }

    /**
     * sets the event message id. By setting the event message id, the offline
     * event will be cleared if it exists.  The event message id should be
     * the original sender's real Message ID (from the <message> tag).
     */
    public void setEventMessageID(String msgID) {
        this.msgID = msgID;
        offline = false;
    }

    public boolean isOffline() {
        return offline;
    }

    public boolean isDisplayed() {
        return displayed;
    }

    public boolean isComposing() {
        return composing;
    }

    public boolean isDelivered() {
        return delivered;
    }

    /**
     * this method checks for you to see if all the event flags are NOT set.
     * This is useful when you need to find out if the message is sent to you
     * to reset the event status (ie. clear the "composing" status when idle timeout occurs).
     */
    public boolean isAllClear() {
        if (!offline && !delivered && !composing && !displayed)
            return true;
        return false;
    }

    /**
     * sets the offline flag.  By setting the offline to true, the message id will
     * automatically be cleared because offline events are only sent in requests while messsage id's are sent only in replies.
     */
    public void setOffline(boolean offline) {
        this.offline = offline;
        if (offline)
            msgID = null;
    }

    public void setDisplayed(boolean displayed) {
        this.displayed = displayed;
    }

    public void setComposing(boolean composing) {
        this.composing = composing;
    }

    public void setDelivered(boolean delivered) {
        this.delivered = delivered;
    }

    /**
     * parses out the data from the message
     */
    public JabberMessage parse(JabberMessageParser parser, Element msgTree) throws ParseException {
        super.parse(parser, msgTree);
        //check for existence of the events
        List list = msgTree.getChildren();
        int len = list.size();
        Element event;
        for (int i = 0; i < len; i++) {
            event = (Element) list.get(i);
            if (event.getName().equals(EVENT_OFFLINE))
                offline = true;
            else if (event.getName().equals(EVENT_DELIVERED))
                delivered = true;
            else if (event.getName().equals(EVENT_COMPOSING))
                composing = true;
            else if (event.getName().equals(EVENT_DISPLAYED))
                displayed = true;
            else if (event.getName().equals("id"))
                msgID = event.getText();
        }
        return this;
    }

    /**
     * overrides the parent's method to first add the stored attributes into the DOM and
     * then call the parent's method to encode the data into a string.
     */
    public String encode() throws ParseException {
        //add all the attributes into the tree
        Element x = getDOM();
        //remove any children first
        x.getChildren().clear();
        if (displayed)
            x.addContent(new Element("displayed", XMLNS_X_EVENT));
        if (delivered)
            x.addContent(new Element("delivered", XMLNS_X_EVENT));
        if (composing)
            x.addContent(new Element("composing", XMLNS_X_EVENT));
        if (offline)
            x.addContent(new Element("offline", XMLNS_X_EVENT));
        if (msgID != null)
            x.addContent((new Element("displayed", XMLNS_X_EVENT)).addContent(msgID));
        return super.encode();
    }

    public int getMessageType() {
        return MSG_X_EVENT;
    }
}
